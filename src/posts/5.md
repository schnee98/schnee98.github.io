---
title: "브라우저가 쉴 수 있게 도와주기!"
date: "2024-08-25"
description: "고오오급 기술이 언제나 필요할까?"
thumbnail: "img/posts/5/thumbnail.png"
---


8월 초부터 **토스**에서 프론트엔드 개발 어시스턴트로 일할 기회를 얻게 되었습니다! 🎉

새로운 직장에서의 경험은 매우 흥미로웠고, 모든 부분에서 많이 배우고 있습니다.

이번 포스트에서는 제가 실제로 겪었던 DOM 노드 최적화 사례와 그 과정에서 배운 점들을 공유하고자 합니다.

# 우리의 어플리케이션이 느려지는 이유..

우리가 개발하는 웹 페이지가 느려지는 이유는 다양하지만, 그 중에서도 리플로우(Reflow)와 리페인트(Repaint)는 중요한 역할을 합니다.

이 두 가지는 브라우저가 화면을 렌더링할 때 발생하는 주요 과정으로, 최적화되지 않으면 성능 저하를 유발할 수 있습니다.

## 리플로우(Reflow)

리플로우는 웹 페이지의 레이아웃을 다시 계산하는 과정으로, DOM(Document Object Model) 구조나 스타일이 변경될 때 발생합니다.

브라우저는 이러한 변경 사항을 반영하기 위해 전체 페이지 또는 일부 요소의 레이아웃을 다시 계산하고, 이를 렌더링하여 사용자가 보게 됩니다.

### 리플로우의 주요 과정

- **DOM 구조 분석**: 브라우저는 HTML을 파싱하여 DOM 트리를 구축합니다. 이는 문서의 구조를 나타내며, 각 노드는 문서의 요소 (예: `<div>`, `<p>` 등)를 나타냅니다.
- **스타일 계산**: DOM 트리가 만들어진 후, 브라우저는 각 요소에 적용될 CSS 스타일을 계산합니다. 이를 통해 각 요소의 색상, 크기, 폰트 등의 스타일이 결정됩니다.
- **레이아웃 계산(리플로우)**: 스타일이 계산된 후, 브라우저는 각 요소의 크기와 위치를 계산하여 요소들을 화면에 배치합니다. 이 과정에서 요소들이 서로 어떻게 배치될지 결정되며, 이 과정이 바로 리플로우입니다.

## 리페인트(Repaint)

리페인트는 웹 페이지에서 요소의 시각적 속성, 즉 색상, 테두리, 그림자 등과 같이 레이아웃 구조에는 영향을 주지 않지만, 시각적으로 표현되는 속성들이 변경될 때 발생하는 과정입니다. 리플로우가 레이아웃을 다시 계산하고 배치하는 작업이라면, 리페인트는 이미 계산된 레이아웃을 바탕으로 변경된 스타일을 화면에 다시 그리는 작업입니다.

### 리페인트의 주요 과정

- **레이아웃 계산 이후**: 리플로우 과정이 완료된 후, 브라우저는 각 요소의 위치와 크기를 알고 있습니다. 리페인트는 이 정보를 기반으로 요소의 시각적 속성을 다시 그리는 과정입니다.
- **시각적 속성 변경 감지**: 요소의 시각적 속성이 변경되면 브라우저는 해당 요소를 화면에 다시 그려야 합니다. 이때 레이아웃 자체는 변경되지 않기 때문에 리플로우는 필요하지 않지만, 화면에 표시되는 내용을 새롭게 그려야 하므로 리페인트가 발생합니다.
- **렌더 트리 업데이트**: 리페인트 시 브라우저는 변경된 스타일을 반영하여 렌더 트리(render tree)를 업데이트합니다. 이 렌더 트리는 각 요소의 시각적 표현을 나타내며, 이를 바탕으로 화면에 요소를 다시 그립니다.

## 참고: 리렌더링(Re-rendering)

리렌더링은 웹 어플리케이션 (특히, 리액트 기반 어플리케이션) 에서 전체 UI를 다시 그리는 과정을 의미합니다. 이 과정은 리플로우나 리페인트보다 더 광범위하고 복잡한 작업을 수반하며, 성능에 상당한 영향을 미칠 수 있습니다. 특히, 리액트(React)와 같은 현대적인 프론트엔드 라이브러리나 프레임워크에서 리렌더링은 중요한 개념으로, 사용자 인터페이스의 상태가 변경될 때 UI를 최신 상태로 유지하기 위해 자주 사용됩니다.

### 리렌더링의 주요 과정

- **상태와 속성 변화 감지**: 리액트와 같은 프레임워크에서는 컴포넌트의 상태(state)나 속성(props)이 변경되면 이를 감지하여 해당 컴포넌트를 다시 렌더링하려고 시도합니다.
- **가상 DOM(Virtual DOM) 업데이트**: 리액트에서는 변경된 상태나 속성을 기반으로 가상 DOM이 업데이트됩니다. 가상 DOM은 브라우저의 실제 DOM과 비교적 가벼운 구조로, UI 변경을 추적하고 필요한 부분만 업데이트하는 데 사용됩니다.
- **실제 DOM 업데이트**: 가상 DOM이 업데이트된 후, 리액트는 이를 실제 DOM과 비교(diffing)하여 변경된 부분만 업데이트합니다. 이 과정에서 리렌더링이 발생하며, 브라우저는 변경된 요소들을 다시 그리게 됩니다.
- **UI 재구성**: 변경된 부분이 실제 DOM에 반영되면서, 사용자는 최신 상태의 UI를 보게 됩니다.

## 실제 사례: 코드 리뷰

이전까지 DOM 노드 변경에 영향을 끼치는 이유들에 대해서 알아보았는데요.

이번엔 직접 사례를 보며 어떤 방식으로 저의 코드를 개선했는지 이야기 해보겠습니다.

제가 당시에 기능했던 기능은 모달 안에 썸네일을 보여주고, 모달이 `hover` 되면 버튼이 보이는 방식으로 동작하는 것이었습니다. 

- 리뷰 전 코드 (Worst Case)

```js

function Modal() {
  const iconRef = useRef(null);

  const handleMouseOver = () => {
    if (iconRef.current == null) {
      return;
    }

    iconRef.current.opacity = '1';
  }

  const handleMouseLeave = () => {
    if (iconRef.current == null) {
      return;
    }

    iconRef.current.opacity = '';
  }

  return (
    <ModalContainer
      onMouseOver={handleMouseOver}
      onMouseLeave={handleMouseLeave}
    >
      <Thumbnail>
        <Icon ref={iconRef} />
      </Thumbnail>
      <Content>
        ...
      </Content>
    </ModalContainer>
  )
}
```

처음 작성한 코드에서는 ref를 사용해 직접 DOM 요소의 스타일을 변경했습니다. 이는 리플로우를 자주 발생시켜 성능에 큰 영향을 미쳤습니다.

- 리뷰로 제안된 코드

```js
function Modal() {
  const [showIcon, setShowIcon] = useState(false);

  const handleMouseOver = () => setShowIcon(true);
  const handleMouseLeave = () => setShowIcon(false);

  return (
    <ModalContainer
      onMouseOver={handleMouseOver}
      onMouseLeave={handleMouseLeave}
    >
      <Thumbnail>
        <Icon />
      </Thumbnail>
      <Content>
        ...
      </Content>
    </ModalContainer>
  )
}
```

리뷰를 통해 state를 사용해 동적으로 스타일링하는 방법을 제안받았습니다. 이 방법은 DOM 노드를 리액트 안에서 직접 조작하지 않도록 하여 성능을 일부 개선하는 방법이었습니다.

- 최종 반영된 코드 (Best Case)

```js
function Modal() {
  return (
    <ModalContainer>
      <Thumbnail>
        <Icon />
      </Thumbnail>
      <Content>
        ...
      </Content>
    </ModalContainer>
  )
}

const ModalContainer = styled.div`
  ...

  &:hover svg {
    opacity: 1;
  }
`;

const Icon = styled(IconMono)`
  opacity: 0;
  transition: opacity 0.5s ease;
`;
```

최종적으로는 CSS만으로 스타일 변경을 처리하는 방법을 사용했습니다. 이를 통해 리플로우와 리렌더링을 모두 최소화하며, 가장 효율적인 성능을 달성할 수 있었습니다.

## 느낀 점

> **기초가 더 중요하다**

주니어 개발자분들이 리액트의 최신 라이브러리나 유명한 기술 스택을 배우는데 집중하는 경우가 많은데,

제 생각은 오히려 기초적인 동작과 흐름을 이해하는게 더 좋다고 생각하고, 이번 사례를 통해 이 생각이 더 굳건해진 것 같습니다.

작은 프로젝트나 어플리케이션을 만드는데에 편하고 빠른 라이브러리나 기술이 좋을 수는 있지만,

문제의 복잡도가 조금만 올라도 HTML/CSS, 자바스크립트 혹은 로우레벨의 지식들이 훨씬 더 빛을 발하는 것 같습니다.

앞서 드린 사례에서 저의 코드가 Worst Case로 남고, 그 뒤의 다른 기능들도 같은 방식으로 구현한다면 어떻게 될까요?

기능이 추가될 수록, Interaction이 많아질 수록, DOM 노드를 변경하는 동작이 기하급수적으로 많아지고 결국에는 어플리케이션이 느려지게 됩니다.

극단적으로 말하자면, 어느 순간부터 사용자는 여러분의 어플리케이션을 더 이상 이용하고 싶지 않게 될 수도 있습니다.

저도 이번 태스크로 더 기초를 더 잘 다룰 수 있도록 많이 배우고, 평소에 더 많이 고려하고 기능을 구현해야겠다고 생각이 듭니다.